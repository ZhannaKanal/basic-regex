Regular Expression or a regex
are a feature supported by many different programming languages.
A regular expression is a special syntax to create a "pattern", which you can then use to check against a string, extract text, or more.
Basic regular expression:
const regex = /freeCodeCamp/;
This particular regular expression will match the text freeCodeCamp, with capital C's, anywhere in a string.
test() method is present on RegExp objects, which are objects representing a regular expression(such as the one we just defined).
The test() method accepts a string, which is the string to test for matches against the regular expression. 
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test);
test() method returned false because the string e doesnot match the pattern freeCodeCamp. Even though the pattern freeCodeCamp includes the letter e, that's the opposite direction of how regular expressions work.
F/e:
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp")); //true
console.log(regex.test("freeCodeCamp is great")); //true
console.log(regex.test("I love freeCodeCamp")); //true
console.log(regex.test("freecodecamp")); //false
console.log(regex.test("FREECODECAMP")); //false
console.log(regex.test("free")); // false
console.log(regex.test("code")); //false 
console.log(regex.test("camp")); //false
The test() method returns a boolean, indicating whether the string matches the regular expression at all.

match() method accepts a regular expression, although you can also pass a string which will be constructed into a regular expression.
match() returns the match array for the string.
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
If we run it, we get an array back. But it's a strange looking array.
[
    'freeCodeCamp',
    index: 0,
    input: 'freeCodeCamp',
    groups: undefined
]
The groups property would show any captured groups. 
The index property tells you at what character in the string the match was found. In our case , it's the beginning of the string.
The input property tells you the string the match() method was called on.
const regex = /freeCodeCamp/;
console.log("freeCodeCamp".match(regex)); // ['freeCodeCamp', index: 0, input: 'freeCodeCamp', groups: undefined]
console.log("freeCodeCamp is great".match(regex)); // ['freeCodeCamp', index: 0, input: 'freeCodeCamp is great', groups: undefined]
console.log("I love freeCodeCamp".match(regex)); // ['freeCodeCamp', index: 7, input: 'I love freeCodeCamp', groups: undefined]
console.log("freecodecamp".match(regex)); // null
console.log("FREECODECAMP".match(regex)); // null
console.log("free".match(regex)); // null
the input and index have changed depending on the string provided
const regex = /freecodecamp/;
const str = "freecodecamp is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced);
repalce() method returns the updated string with the matching pattern replaced.

Regular Expression Modifiers used for Searching
Modifiers, often referred to as "flags", modify the behavior of a regular ecpression.
If you remember, the all-lowercase and all-uppercase freeCodeCamp strings failed to match the pattern.
This is, because, by default, regular expressions are case-sensitive.
but what will be if we add i to the end of regex;
The i flag makes a regex ignore a case.
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
The g flag, global modifier, allows your regular expression to match a pattern more than once.
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // true
When a regular expression is global, it gets a new property called lastIndex.
console.log(regex.lastIndex) //0
The caret(^) anchor, at the beginning of the regular expression, says "match the start of the string"
const start = /^freecodecamp/i;
The dollar sign ($) anchor, at the end of the regular expression, says "match the end of the string"
const end = /freeCodeCamp$/i;
You can make a regex handle multiple lines with the m flag, multi-line modifier.
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)) // true
console.log(end.text(string)) // true
The d flag, indices modifier, expands the information you get in a match object.
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex)) //
// [
//   'freecodecamp',
//   index: 8,
//   input: "we love freecodecamp isn't freecodecamp great?",
//   groups: undefined,
//   indices: [
//     0: [8, 20],
//     groups: undefined
//   ]
// ]
The u flag, unicode modifier, expands the functionality of a regular expression to allow it to match special unicode characters.
const regex = /üçé/u;
const str = "I have an apple üçé";
console.log(regex.test(str)); // true
The y flag, sticky modifier behaves very similarity to the global modifier, will return null and reset the lastIndex to 0 if there is not immediately a match at the previous lastIndex.
The global regular expression will start from lastIndex and search the entire remainder of the string for another match
The s flag, single-line modifier, allows a wildcard character, represented by a period (.) in regex, to match linebreaks - effectively treating the string as a single line of text.

Match and Replace All Occurrences in a string
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced =  str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
result will {} and freeCodeCamp is the best we love freeCodeCamp
replaceAll() method worked exactly as we wanted.
But matchAll() returns a special type of object called an Iterator, which the freeCodeCamp console isn't prepared to handle.
Iterator has a next() method, if we call matched.next(), the result will
{
    "done":false,
    "value": [
        0: "freecodecamp"
        groups: undefined
        index: 0
        input: "freecodecamp is the best we love freecodecamp"
    ]
}
