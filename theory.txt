Regular Expression or a regex
are a feature supported by many different programming languages.
A regular expression is a special syntax to create a "pattern", which you can then use to check against a string, extract text, or more.
Basic regular expression:
const regex = /freeCodeCamp/;
This particular regular expression will match the text freeCodeCamp, with capital C's, anywhere in a string.
test() method is present on RegExp objects, which are objects representing a regular expression(such as the one we just defined).
The test() method accepts a string, which is the string to test for matches against the regular expression. 
const regex = /freeCodeCamp/;
const test = regex.test("e");
console.log(test);
test() method returned false because the string e doesnot match the pattern freeCodeCamp. Even though the pattern freeCodeCamp includes the letter e, that's the opposite direction of how regular expressions work.
F/e:
const regex = /freeCodeCamp/;
console.log(regex.test("freeCodeCamp")); //true
console.log(regex.test("freeCodeCamp is great")); //true
console.log(regex.test("I love freeCodeCamp")); //true
console.log(regex.test("freecodecamp")); //false
console.log(regex.test("FREECODECAMP")); //false
console.log(regex.test("free")); // false
console.log(regex.test("code")); //false 
console.log(regex.test("camp")); //false
The test() method returns a boolean, indicating whether the string matches the regular expression at all.

match() method accepts a regular expression, although you can also pass a string which will be constructed into a regular expression.
match() returns the match array for the string.
const regex = /freeCodeCamp/;
const match = "freeCodeCamp".match(regex);
console.log(match);
If we run it, we get an array back. But it's a strange looking array.
[
    'freeCodeCamp',
    index: 0,
    input: 'freeCodeCamp',
    groups: undefined
]
The groups property would show any captured groups. 
The index property tells you at what character in the string the match was found. In our case , it's the beginning of the string.
The input property tells you the string the match() method was called on.
const regex = /freeCodeCamp/;
console.log("freeCodeCamp".match(regex)); // ['freeCodeCamp', index: 0, input: 'freeCodeCamp', groups: undefined]
console.log("freeCodeCamp is great".match(regex)); // ['freeCodeCamp', index: 0, input: 'freeCodeCamp is great', groups: undefined]
console.log("I love freeCodeCamp".match(regex)); // ['freeCodeCamp', index: 7, input: 'I love freeCodeCamp', groups: undefined]
console.log("freecodecamp".match(regex)); // null
console.log("FREECODECAMP".match(regex)); // null
console.log("free".match(regex)); // null
the input and index have changed depending on the string provided
const regex = /freecodecamp/;
const str = "freecodecamp is rly kewl";
const replaced = str.replace(regex, "freeCodeCamp");
console.log(replaced);
repalce() method returns the updated string with the matching pattern replaced.

Regular Expression Modifiers used for Searching
Modifiers, often referred to as "flags", modify the behavior of a regular ecpression.
If you remember, the all-lowercase and all-uppercase freeCodeCamp strings failed to match the pattern.
This is, because, by default, regular expressions are case-sensitive.
but what will be if we add i to the end of regex;
The i flag makes a regex ignore a case.
const regex = /freeCodeCamp/i;
console.log(regex.test("freecodecamp")); // true
console.log(regex.test("FREECODECAMP")); // true
The g flag, global modifier, allows your regular expression to match a pattern more than once.
const regex = /freeCodeCamp/gi;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("freeCodeCamp is great")); // false
console.log(regex.test("I love freeCodeCamp")); // true
console.log(regex.test("freecodecamp")); // false
console.log(regex.test("FREECODECAMP")); // true
When a regular expression is global, it gets a new property called lastIndex.
console.log(regex.lastIndex) //0
The caret(^) anchor, at the beginning of the regular expression, says "match the start of the string"
const start = /^freecodecamp/i;
The dollar sign ($) anchor, at the end of the regular expression, says "match the end of the string"
const end = /freeCodeCamp$/i;
You can make a regex handle multiple lines with the m flag, multi-line modifier.
const start = /^freecodecamp/i;
const end = /freecodecamp$/i;
const string = `I really love
freecodecamp
it's my favorite`;
console.log(start.test(string)) // true
console.log(end.text(string)) // true
The d flag, indices modifier, expands the information you get in a match object.
const regex = /freecodecamp/di;
const string = "we love freecodecamp isn't freecodecamp great?";
console.log(string.match(regex)) //
// [
//   'freecodecamp',
//   index: 8,
//   input: "we love freecodecamp isn't freecodecamp great?",
//   groups: undefined,
//   indices: [
//     0: [8, 20],
//     groups: undefined
//   ]
// ]
The u flag, unicode modifier, expands the functionality of a regular expression to allow it to match special unicode characters.
const regex = /üçé/u;
const str = "I have an apple üçé";
console.log(regex.test(str)); // true
The y flag, sticky modifier behaves very similarity to the global modifier, will return null and reset the lastIndex to 0 if there is not immediately a match at the previous lastIndex.
The global regular expression will start from lastIndex and search the entire remainder of the string for another match
The s flag, single-line modifier, allows a wildcard character, represented by a period (.) in regex, to match linebreaks - effectively treating the string as a single line of text.

Match and Replace All Occurrences in a string
const pattern = "freecodecamp";
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(pattern);
const replaced =  str.replaceAll(pattern, "freeCodeCamp");
console.log(matched);
console.log(replaced);
result will {} and freeCodeCamp is the best we love freeCodeCamp
replaceAll() method worked exactly as we wanted.
But matchAll() returns a special type of object called an Iterator, which the freeCodeCamp console isn't prepared to handle.
Iterator has a next() method, if we call matched.next(), the result will
{
    "done":false,
    "value": [
        0: "freecodecamp"
        groups: undefined
        index: 0
        input: "freecodecamp is the best we love freecodecamp"
    ]
}
but matchAll() method finds at one time only one of match,
to extract all of the matches at once by converting it to an array.
This is achieved by calling Array.from() and passing your iterator as the argument.
const regex = /freecodecamp/g;
const str = "freecodecamp is the best we love freecodecamp";
const matched = str.matchAll(regex);
console.log(Array.from(matched));
finally the result will be 
// [
//   'freecodecamp',
//   index: 0,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]
//
// [
//   'freecodecamp',
//   index: 33,
//   input: 'freecodecamp is the best we love freecodecamp',
//   groups: undefined
// ]

Character Classes, and Some Common Examples
are a special syntax you can use to match sets or subsets of characters.
The wildcard class is represented by a period or dot (.) and matches any single character except line breaks.
To allow the wildcard class to match line breaks, remember that you would need to use the s flag.
A regular expression that matched the letter a followed by one single character might look like:
const regex = /a./;
It's helpful when you are looking for a specific patterns in a string, but dont know what might be between those two patterns.
If you want to match a numerical character, you might have to write out every possible digit, separating them with the or operator (|);
const regex = /0|1|2|3|4|5|6|7|8|9/;
If we write backslash(\) followed by a d character:
cosnt regex = /\d/;
This regex will match the exact same pattern as our previous expression: a single numerical character anywhere in the string.
To match any letter from a through z, you can write them by or operator.
Or you could write like \w, which represents any word character.
const regex = /\w/;
A word character is defined as any letter, from a to z, or a number from 0 to 9, or the underscore(_) character.
\s will match any whitespace, including new lines, spaces, tabs, and special unicode space characters.
const regex = /\D/;
This doesnt match a numerical character, matches any single character that is not a numerical character.
If you want to match more specific subsets of characters
const regex = /[abcdf]/;
this will match a single char that is in the list a, b, c, d, f
const regex = /[a-d]/; same as [abcd]
const regex = /[a-zA-Z]/;
if you want version without underscore
const ragex = /[a-zA-Z0-9]/;
if you want match a literal hyphen, you need to place a hyphen at the brginning or at the end of the class
const regex = /[-a-zA-Z0-9]/;

Lookahead and Lookbehind Assertions
allow you to match specific patterns based on the presence or lack of surrounding patterns.
Positive lookahead assertion will match a pattern when the pattern is followed by another pattern.
const regex = /free(?=code)/i; // matches the word free if it is followed by code
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
If you want to match the presence of free when it is NOT followed by code,
you can turn your positive lookahead into a negative lookahead to invert the behavior.
To do this, change your ?= to ?!
const regex = /free(?!code)/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true

Lookbehind assertions function similarly to lookahead assertions, except that,
instead of matching conditionally based on a following pattern, they match conditionally based on a preceding pattern.
Positive lookahead is denoted with ?<= instead of ?=
const regex = /(?<=free)code/i;
console.log(regex.test("freeCodeCamp")); // true
console.log(regex.test("free code camp")); // false
matches the first string because code is immediately preceded by free
To match code when it is NOT preceded by free, we can use a negative lookbehind.
is defined with ?<!
const regex = /(?<!free)code/i;
console.log(regex.test("freeCodeCamp")); // false
console.log(regex.test("free code camp")); // true
this would match any occurrences of code that is NOT immediately preceded by free

Regex.prototype.test only confirms whether a string matches the regular expression.
const regex = /(?<!free)code/i;
console.log("freeCodeCamp".match(regex)); // null
console.log("free code camp".match(regex)); // ['code', index: 5, input: 'free code camp', groups: undefined]
